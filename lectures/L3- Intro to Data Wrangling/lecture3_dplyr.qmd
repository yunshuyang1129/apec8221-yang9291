---
title: "Lecture 3: Data Manipulation数据操作 (dplyr)"
subtitle: "APEC 8221: Programming for Econometrics"
author: "Ali Joglekar"
date: "September 9, 2025"
format:
  html:
    toc: true 
    toc-depth: 3
    toc-location: left
    number-sections: true
    code-fold: show
    code-tools: true
    theme: cosmo
    embed-resources: true
execute:
  warning: true
  message: true
  eval: true
  echo: true
editor: visual
---

# Opening & Check-In

## Assignment 0 Status Check

Any lingering Git issues?

## Today's Mission

Today we dive into the heart of data manipulation with `dplyr`—the grammar of data transformation数据转换的语法. By the end of today, you'll be able to take messy, real-world datasets and transform them into exactly what you need for analysis.

**Why this matters:**

-   Data preparation is widely recognized as the most consuming aspect of quantitative research
    -   80/20 rule ⟶ 80% cleaning & 20% analysis
-   `dplyr` makes this process readable, reproducible, and surprisingly enjoyable

**Real scenario:** You're analyzing the impact of trade policy on economic growth. Your raw data has 47 countries, 30 years, multiple variables, and you need to calculate growth rates增长率, filter specific time periods, and summarize by region.

Today you'll learn to do this with elegant简洁, readable code.

## Packages

For today's exercises, you'll need to install the `gapminder` package，这个包包含了各国在不同年份的寿命、GDP、人均收入等指标，非常适合练习数据处理.

```{r}
#| label: packages
# 给这个代码块起名字 packages，方便引用

package_names <- c("gapminder")
#定义一个变量 package_names，里面存放要安装的包名（这里只有 "gapminder"）。写成向量形式是为了以后可以一次性写多个包名

# Check if the packages are installed，判断 R 环境里是否存在这个包，不显示提示信息。
if (!requireNamespace(package_names, quietly = TRUE)) {
  # If not installed, install the packages
  install.packages(package_names)
}
```

# The `tidyverse` Philosophy & `dplyr` Overview (`I Do`)

## What is the `tidyverse`?

The **`tidyverse`** is a collection of R packages designed to work together seamlessly for data science. Think of it as a "standard library" for modern data analysis.你可以把 tidyverse 理解为“现代数据分析的标准库”

Contains 9 core packages:

-   `ggplot2` (visualization)
-   `dplyr` (data manipulation)
-   `tidyr` (data tidying)
-   `readr` (data import)
-   `purrr` (functional programming)
-   `tibble` (modern data frames)
-   `stringr` (string manipulation)
-   `forcats` (factor handling)
-   `lubridate` (working with date-times)

![](images/clipboard-1073675801.png){width="326"}

```{r}
#| label: load-tidyverse
#给这个代码块起名 load-tidyverse，然后加载 tidyverse 整个集合4
library(tidyverse)
```

::: callout-note
The `::` function allows you to call a function from within a package without attaching the package to your work space (`dplyr::filter()` versus `filter()`).
:::

::: callout-important
After attaching the `tidyverse` package to your work space, you get a couple of "conflicts".

What do you think "`dplyr::filter()` masks `stats::filter()`" means? How would you use the `filter()` function within the `dplyr` package? Within the `stats` package?
:::

## ![](images/clipboard-2863693809.png){width="283"}

![](images/clipboard-854611721.png){width="361"}

## Core Design Principles

1.  **Consistent API**: Similar function signatures across packages降低学习成本
2.  **Pipe-friendly**: Functions designed for `%>%` or `|>` operators代码可以从上到下顺畅阅读
3.  **Human-readable**: Function names that describe what they do
4.  **Tidy data**: Each variable is a column, each observation is a row每个变量是一列，每个观测值是一行

## Our Dataset: `gapminder`

We'll use the `gapminder` dataset—perfect for learning `dplyr` because it's clean, real, and interesting. [Gapminder](https://www.gapminder.org/) is an independent educational non-proﬁt "ﬁghting global misconceptions对抗全球误解."

```{r}
#| label: gapminder-structure

library(gapminder)

# Look at the structure
glimpse(gapminder)
```

![](images/clipboard-3209973404.png){width="358"}

::: callout-note
Both `dplyr::glimpse()` and `str()` are used to examine the structure of data objects, but they have different outputs and focus areas.

+-----------------------------------------------------+---------------------------------------------------------+
| `dplyr::glimpse()`                                  | `str()`                                                 |
+=====================================================+=========================================================+
| -   Quick data exploration at the start of analysis | -   You need detailed technical information             |
| -   You want a clean, readable overview             | -   Working with complex nested objects (lists, models) |
| -   Working with tidyverse workflows                | -   Debugging data type issues                          |
| -   Presenting data structure to others             | -   You want to see exact factor levels or attributes   |
+-----------------------------------------------------+---------------------------------------------------------+
:::

![](images/clipboard-3922734952.png){width="394"}

```{r}
#| label: gapminder-head。#代码块命名


# What are we working with?默认显示变量名和前六行观测值
head(gapminder)
```

head will defaultly show first 6 rows we can also customize the rows number we wanna see:

```{r}
head(gapminder, 10)
```

This dataset contains:

-   **1,704 observations** across 142 countries
-   **6 variables**: country, continent, year, life expectancy, population, GDP per capita
-   **Time span**: 1952-2007 (every 5 years)

Perfect for asking economic questions like: "Which countries had the fastest economic growth?" or "How does life expectancy relate to GDP?"

::: callout-note
## Data Objects

Data of different types make up different classes of objects. To some extent you can think of these as different shapes.

-   *Vectors* are one-dimensional sets of values and contain only one data type (`+` maybe special values). Class is usually same as the data type.
-   *Matrices* are rectangular arrays of values of one type (`+` maybe special values). Class is `"matrix"`.
-   *Data frames* are rectangular arrays, but the columns can be different types. These are the standard way to handle data sets in R. Class is `"data.frame"`.
-   *Lists* can contain nearly anything in any combination. Can be irregular “trees.” Obviously versatile, but correspondingly harder to work with. Class is `"list"`.

Other data classes include *arrays*, *character*, *complex*, *double*, *factor*, *logical*, *raw*, and *time series*.
:::

![](images/clipboard-3256468776.png){width="407"}

现代tidyverse默认选择tibble

::: callout-note
## tibble vs data.frame

`tibbles` are generally preferred for new work due to their safer, more predictable behavior, while `data.frames` remain important for compatibility with base R and legacy code.

| Feature | `data.frame` | `tibble` | Example |
|----|----|----|----|
| **Printing** | Prints all rows (can flood console) | Smart printing: shows dimensions, types, first 10 rows | `mtcars` vs `as_tibble(mtcars)` |
| **Subsetting with `[,]`** | Can return vector (dimension drops) | Always returns tibble | `df[, 1]` → vector vs `tb[, 1]` → tibble |
| **Column Names** | Auto-"fixes" names, converts spaces to dots | Preserves any valid name (spaces, numbers, emojis) | `data.frame(`my var`= 1)` → `my.var` vs tibble preserves `my var` |
| **Partial Matching `$`** | Allows dangerous partial matching | Requires exact column names | `df$va` might match `variable` vs `tb$va` → `NULL` |
| **String Handling** | Historically converted to factors | Keeps strings as characters | `data.frame(x = "text")` vs `tibble(x = "text")` |
| **Vector Recycling** | Silent recycling (can hide errors) | Strict recycling rules | `data.frame(x = 1:4, y = 1:2)` works vs tibble throws error |
| **Row Names** | Supports row names | Discourages row names (use columns instead) | `rownames(df) <- letters[1:3]` vs explicit name column |
| **Type Stability** | Inconsistent return types | Predictable return types | Subsetting behavior varies vs always consistent |
| **Error Messages** | Generic base R errors | Informative tidyverse-style errors | Less helpful vs more descriptive error messages |
| **Performance** | Slightly faster (less overhead) | Slightly slower (more checks) | Marginal difference for most use cases |
:::

## The Five Essential `dplyr` Verbs五个基本动词

Think of `dplyr` verbs as the fundamental operations you perform on data:

1.  **`select()`** – Pick columns (variables)
2.  **`filter()`** – Pick rows (observations)
3.  **`arrange()`** – Sort rows
4.  **`mutate()`** – Create new variables
5.  **`summarise()`** – Calculate summary statistics

![](images/clipboard-2119124752.png){width="382"}

## Live Demo: Building a Data Pipeline

| **What were the 5 countries with highest GDP per capita growth between 1952 and 2007?**

```{r}
#| label: pipeline-demo

# Step 1: Look at the data structure first
gapminder %>% 
  select(country, year, gdpPercap) %>%
  head()

# Step 2: Calculate GDP growth for each country
gdp_growth <- gapminder %>%
  # Only keep countries with data for both 1952 and 2007
  filter(year %in% c(1952, 2007)) %>%
  # Keep relevant columns
  select(country, continent, year, gdpPercap) %>%
  # Reshape to calculate growth，把长表year，gdppercap转成宽表gdp—1952，gdp-2007
  pivot_wider(names_from = year, 
              values_from = gdpPercap,
              names_prefix = "gdp_") %>%
  # Calculate growth rate，新增两列变量
  mutate(
    gdp_growth_rate = (gdp_2007 - gdp_1952) / gdp_1952 * 100,
    gdp_growth_absolute = gdp_2007 - gdp_1952
  ) %>%
  # Sort by growth rate
  arrange(desc(gdp_growth_rate)) %>%
  # Get top 5
  slice_head(n = 5) %>%
  print(gdp_growth) %>%

  # Get first 25%
  slice_head(prop = .25)
  print(gdp_growth)
```

**What just happened?** We chained together multiple operations to answer a research question. Each `%>%` passes the result to the next function. Equivalent without pipes → heavily nested and harder to read.如果不用管道，就要写成一层层镶嵌的函数，即难写又难读

### The Power of the Pipe Operator

The pipe operator (`%>%` or `|>`) makes code readable from left to right:

::: callout-important
For most day-to-day tidyverse work, both pipes work identically. Use `|>` for simple cases and better performance, use `%>%` when you need its extra flexibility or are working with older R versions. Many experienced users are gradually shifting to `|>` for new code while keeping `%>%` for complex operations.
:::

```{r}
#| label: pipe-comparison
#| eval: false

# Without pipes (hard to read)
slice_head(arrange(mutate(filter(gapminder, year == 2007), 
                         gdp_billions = gdpPercap * pop / 1e9),
                  desc(gdp_billions)), n = 3)

# With pipes (reads like English)
gapminder %>%
  filter(year == 2007) %>%
  mutate(gdp_billions = gdpPercap * pop / 1e9) %>%
  arrange(desc(gdp_billions)) %>%
  slice_head(n = 3) 
```

**Keyboard shortcut:** `Ctrl+Shift+M` (Windows) or `Cmd+Shift+M` (Mac)，

## Grouped Operations with group_by()

The real power comes with **grouped operations分组操作**—performing calculations within groups:

```{r}
#| label: grouped-operations

# What's the average life expectancy by continent大洲 over time?
life_exp_by_continent <- gapminder %>%
  group_by(continent, year) %>%
  summarise(
    avg_life_exp = mean(lifeExp),
    countries_count = n(),
    .groups = "drop"  # Good practice to to ensure subsequent operations are applied to the entire dataset, not within specific groups，解除分组，避免后续操作继续在分组里运行，是好习惯
  )

print(life_exp_by_continent) #会显示每个大洲，每年对应的结果，是long dataset

# Let's see the most recent data
life_exp_by_continent %>%
  filter(year == 2007) %>%
  arrange(desc(avg_life_exp))
```

**Key insight:** `group_by()` doesn't change your data visually, but it changes how subsequent operations work. Think of it as "setting the context" for calculations.

![](images/clipboard-861047792.png)

# Debugging Interlude调试缓解: Common dplyr Errors

Before we practice together, let's see the most common mistakes and how to fix them:

```{r}
#| label: debugging-demo
#| eval: false

# Show the data first  
names(gapminder)    # Our data columns
head(unique(gapminder$country), 10)   # Sample values in 'country' column

# Mistake 1: Wrong column name
gapminder %>% 
  filter(Country == 'United States') %>% 
# Solution: Check column names with names(data)，country要是小写
names (gapminder) #Then we can have the variable names


# Mistake 2: Wrong value name  
result <- gapminder %>% 
  filter(country == "USA") %>%
  nrow()
# Solution: Check unique values with 
unique(data$column)
#   The correct country name is 'United States

# Mistake 3: Assignment vs comparison
gapminder %>%
  filter(year = 2007)  # Should be ==比较, not =赋值

# Your data debugging toolkit
names(data)           # Check column names
unique(data$column)   # Check unique values 
str(data)             # Check data types
glimpse(data)         # Quick overview
head(data)            # First few rows
```

**Your debugging workflow:**

1.  **READ** the error message carefully
2.  **CHECK** column names with `names(data)`
3.  **VERIFY** values with `unique(data$column)`
4.  **BUILD** your pipe chain step by step
5.  **TEST** each piece before adding the next

# Guided Practice: Building Together (`We Do`)

Let's work through a data manipulation challenge together. I'll start, and you'll help me complete it.

## Research Question

| **"How has the relationship between GDP per capita and life expectancy changed over time?"**

Let me start building the analysis, and the class will help guide the next steps:

```{r}
#| label: we-do-setup

# Start by exploring the relationship in one year
gdp_life_2007 <- gapminder %>%
  filter(year == 2007) %>%
  select(country, continent, gdpPercap, lifeExp)

head(gdp_life_2007)
```

**Class discussion questions:**

1.  What if we want to compare this relationship across multiple years?
2.  Should we look at all years or just a few key years?
3.  How should we summarize this relationship?

**Let's build this together:**

```{r}
#| label: we-do-together

# Class input: What years should we compare?
unique(gapminder$year) #列出所有不重复的年份
key_years <- c(1952, 1977, 2002)

# Class input: How should we structure this data?
gdp_life_comparison <- gapminder %>% #创建一个新对象
  filter(year %in% key_years) %>% #只保留年份在keyyear里的行
  select(country, continent, year, gdpPercap, lifeExp) %>%
  # Class question: What grouping makes sense here?
  group_by(country, year) %>% #意思是之后的计算会在每个国家*每个年份的小组里进行
  # Class question: What summaries should we calculate?
  summarise(
    avg_gdp = mean(gdpPercap),
    avg_life_exp = mean(lifeExp),
    countries = n(),
    .groups = "drop"
  ) %>%
  
  
  # Class question: How should we arrange this?
  arrange(year) #按时间顺序排序

print(gdp_life_comparison)
```

![](images/clipboard-2385222837.png){width="341"}

![](images/clipboard-217181148.png){width="424"}

::: {.callout-note collapse="true"}
## Guided Practice Solution

```{r}
#| label: we-do-together-solution


# Class input: What years should we compare?
key_years <- c(1952, 1977, 2002, 2007)

# Class input: How should we structure this data?
gdp_life_comparison <- gapminder %>%
  filter(year %in% key_years) %>%
  select(country, continent, year, gdpPercap, lifeExp) %>%
  # Class question: What grouping makes sense here?
  group_by(continent, year) %>%
  # Class question: What summaries should we calculate?
  summarise(
    avg_gdp = mean(gdpPercap),
    avg_life_exp = mean(lifeExp),
    countries = n(),
    .groups = "drop"
  ) %>%
  # Class question: How should we arrange this?这里就不只是只按年份排序了，而是州加年份一起排序，这就是long data
  arrange(continent, year)

print(gdp_life_comparison)
```
:::

**Discussion:** What patterns do you notice? How might we visualize this on Thursday?

![](images/clipboard-1903263849.png)

# Hands-On Practice: Your Turn (`You Do`)

## Core Task: Essential dplyr Practice (25 minutes)

Alright, time to get your hands dirty.

Use the `gapminder` dataset to answer these questions. Work in pairs if you want—sometimes two brains are better than one, especially when debugging.

### Question 1: Country Analysis

Find the **3 countries** with the **highest life expectancy** in **Africa** in **2007**.

::: callout-tip
This is a classic *FILTER* ⟶ *ARRANGE* ⟶ *SLICE* problem. What's happening if you get zero rows?
:::

```{r}
#| label: core-q1
#| eval: false

# Your code here
highest_life_exp_africa <- gapminder %>%
  # Fill in your pipeline

print(highest_life_exp_africa)
```

### ![](images/clipboard-214738618.png){width="430"}

### Question 2: Time Series Analysis

Calculate the **change in GDP per capita** between **1952 and 2007** for **each country**. Show the **top 5 countries** with the **largest absolute increase**.

::: callout-tip
You'll need to reshape the data or get creative with filtering.
:::

```{r}
#| label: core-q2
#| eval: false

# Your code here
gdp_changes <- gapminder %>%
  # Fill in your pipeline

print(gdp_changes)
```

![](images/clipboard-3322191867.png){width="562"}

![](images/clipboard-3824826421.png){width="559"}

### Question 3: Continental Summaries

For the year **2007**, calculate the **total population** and **average GDP per capita** for each **continent**. Sort by total population (descending从大到小，即降序排序).

::: callout-tip
-   Total population ⟶ `sum()`
-   Average GDP per capita ⟶ `mean()`
:::

```{r}
#| label: core-q3
#| eval: false

# Your code here
continental_summary <- gapminder %>%
  # Fill in your pipeline

print(continental_summary)
```

![](images/clipboard-38763880.png){width="467"}

![](images/clipboard-3636435543.png){width="406"}

### Question 4: Population Giants

Find all countries that had a **population greater than 100 million** in **any year**. Show the country, year, and population, sorted by population (descending).

::: callout-tip
This one's straightforward if you think about what "any year" means for your filter.
:::

```{r}
#| label: core-q4
#| eval: false

# Your code here
population_giants <- gapminder %>%
  # Fill in your pipeline

print(population_giants)
```

![](images/clipboard-459206495.png){width="541"}

![](images/clipboard-3865099649.png){width="313"}

## Extension Activities

If you finished the core tasks, try these extension activities:

### Extension 1: Growth Rate Analysis

Calculate the **average annual growth rate** of GDP per capita 人均gdp年均增长率for each country between 1952 and 2007. Show the top 10 fastest-growing countries.

::: callout-tip
Hint: Annual growth rate formula: `((final_value/initial_value)^(1/years) - 1) * 100`

Double hint: You have 55 years of data (2007-1952)
:::

![](images/clipboard-3655787597.png)

```{r}
#| label: ext-1
#| eval: false

# Your code here - this requires some creative thinking
growth_rates <- gapminder %>%
  # Your pipeline here

print(growth_rates)
```

![](images/clipboard-2925289493.png)

![](images/clipboard-1556680314.png){width="357"}

### Extension 2: Correlation Analysis

For each continent, calculate the **correlation coefficient** between GDP per capita and life expectancy using all available years. Which continent has the strongest relationship?

::: callout-tip
Hint: Use `cor()` inside `summarise()`
:::

```{r}
#| label: ext-2
#| eval: false

# Your code here - you'll need cor() function inside summarise()
correlations <- gapminder %>%
  # Your pipeline here

print(correlations)
```

![](images/clipboard-2069599735.png)

![](images/clipboard-2058597990.png){width="313"}

![](images/clipboard-2166090180.png){width="364"}

### ![](images/clipboard-424080243.png){width="304"}

### Extension 3: Complex Filtering

Find countries that experienced **negative GDP growth** in at least one 5-year period. Show the country, the period, and the growth rate.

::: callout-tip
This one's tricky - you'll need to think about how to calculate period-to-period changes.
:::

```{r}
#| label: ext-3
#| eval: false

# Your code here - this is genuinely challenging!
negative_growth <- gapminder %>%
  # Your pipeline here

print(negative_growth)
```

```{r}
negative_growth <- gapminder %>%
  group_by(country) %>% 
  arrange(year) %>% 
  mutate(
    prev_gdp = lag(gdpPercap),   # 上一个年份的人均GDP
    prev_year = lag(year),       # 上一个年份
    growth_rate = (gdpPercap - prev_gdp) / prev_gdp * 100  # 计算增长率 (%)
  ) %>%
  filter(growth_rate < 0) %>%    # 只保留负增长
  select(continent, country, year, prev_year, growth_rate) %>%
  ungroup()

print(negative_growth)
```

## ![](images/clipboard-2611696721.png){width="393"}

## Working Solutions

Here are the solutions - but seriously, don't peek until you've wrestled with the problems. The struggle is where the learning happens.

::: {.callout-note collapse="true"}
## Core Task Solutions

### Question 1 Solution:

```{r}
#| label: solution-q1

highest_life_exp_africa <- gapminder %>%
  filter(continent == "Africa", year == 2007) %>%
  arrange(desc(lifeExp)) %>%
  slice_head(n = 3) %>%
  select(country, lifeExp)

print(highest_life_exp_africa)
```

### Question 2 Solution:

```{r}
#| label: solution-q2

gdp_changes <- gapminder %>%
  filter(year %in% c(1952, 2007)) %>%
  select(country, year, gdpPercap) %>%
  pivot_wider(names_from = year, values_from = gdpPercap, names_prefix = "gdp_") %>%
  mutate(gdp_change = gdp_2007 - gdp_1952) %>%
  arrange(desc(gdp_change)) %>%
  slice_head(n = 5) %>%
  select(country, gdp_1952, gdp_2007, gdp_change)

print(gdp_changes)
```

### Question 3 Solution:

```{r}
#| label: solution-q3

continental_summary <- gapminder %>%
  filter(year == 2007) %>%
  group_by(continent) %>%
  summarise(
    total_population = sum(pop),
    avg_gdp_per_cap = mean(gdpPercap),
    countries = n(),
    .groups = "drop"
  ) %>%
  arrange(desc(total_population))

print(continental_summary)
```

### Question 4 Solution:

```{r}
#| label: solution-q4

population_giants <- gapminder %>%
  filter(pop > 100000000) %>%
  select(country, year, pop) %>%
  arrange(desc(pop))

print(population_giants)
```
:::

::: {.callout-note collapse="true"}
## Extension Activity Solutions

### Extension 1 Solution:

```{r}
#| label: solution-ext1

growth_rates <- gapminder %>%
  filter(year %in% c(1952, 2007)) %>%
  select(country, year, gdpPercap) %>%
  pivot_wider(names_from = year, values_from = gdpPercap, names_prefix = "gdp_") %>%
  mutate(
    annual_growth_rate = ((gdp_2007/gdp_1952)^(1/55) - 1) * 100
  ) %>%
  arrange(desc(annual_growth_rate)) %>%
  slice_head(n = 10) %>%
  select(country, gdp_1952, gdp_2007, annual_growth_rate)

print(growth_rates)
```

### Extension 2 Solution:

```{r}
#| label: solution-ext2

correlations <- gapminder %>%
  group_by(continent) %>%
  summarise(
    correlation = cor(gdpPercap, lifeExp),
    countries = n_distinct(country),
    observations = n(),
    .groups = "drop"
  ) %>%
  arrange(desc(correlation))

print(correlations)
```
:::

# Wrap-Up & Looking Ahead

## What We Learned Today

**The core `dplyr` toolkit:**

-   `select()` – grab the columns you want
-   `filter()` – grab the rows you want
-   `arrange()` – sort your data
-   `mutate()` – create new variables
-   `summarise()` – crunch numbers
-   `group_by()` – do calculations within groups

**The big ideas:**

-   **Pipe operator** (`%>%`) makes code readable (and your life easier)
-   **Grouped operations** let you analyze subsets without splitting datasets
-   **Debugging is normal** - we all make the same mistakes

![](images/clipboard-2080992277.png){width="380"}

## Why This Actually Matters

**Real scenarios where you'll use these exact skills:**

1.  **Policy Analysis:** "How did the minimum wage increase affect employment by industry and state?"

    -   `group_by` industry, state
    -   `mutate` employment_change
    -   `filter` recent years

2.  **Development Economics:** "Which aid interventions had the largest poverty impact?"

    -   `filter` aid_type
    -   `mutate` poverty_reduction
    -   `arrange` by effectiveness

3.  **Trade Research:** "How did NAFTA affect bilateral trade flows?"

    -   `group_by` country_pair
    -   `mutate` trade_growth
    -   `filter` pre_post_nafta

::: callout-important
This isn't academic busywork—it's the foundation of every quantitative research project!
:::

![](images/clipboard-2757107632.png){width="324"}

![](images/clipboard-1657837060.png){width="335"}

## Next Lecture Preview: Making Pretty Pictures

Thursday we'll learn `ggplot2` to turn these data transformations into compelling visualizations. Think of it this way—`dplyr` shapes your data, `ggplot2` makes it tell a story.

### Reading for Thursday

For Thursday's visualization class:

-   **R4DS Chapter 1 (Data Visualization)** – comprehensive `ggplot2` intro

**Helpful extras:**

-   [ggplot2 tutorial](https://r-statistics.co/Complete-Ggplot2-Tutorial-Part1-With-R-Code.html) – if you want extra practice
-   [ggplot2 cheatsheet](https://rstudio.github.io/cheatsheets/html/data-visualization.html) – keep this handy

------------------------------------------------------------------------

**Remember:** Use Canvas discussion board for questions that benefit everyone, and don't hesitate to come to office hours Thursday 10:30-11:30 AM!

![](images/clipboard-2766835972.png){width="338"}
